## Spring MVC 및 DAO 연동 마무리 문제 풀이

### 1\. [개념] Spring MVC 패턴에서 DAO 연동 처리 순서

Spring MVC 패턴에서 사용자 요청을 처리하고 DAO를 통해 데이터베이스와 연동하는 일반적인 순서는 다음과 같습니다. 이 구조는 애플리케이션의 \*\*관심사를 분리(Separation of Concerns)\*\*하여 유지보수성과 확장성을 높입니다.

1.  **클라이언트 (Client) $\rightarrow$ Controller:** 사용자(클라이언트)의 요청(예: `http://.../board/write`)이 들어오면 DispatcherServlet을 거쳐 **Controller**가 받습니다.

      * **역할:** 요청을 매핑하고, 클라이언트로부터 전달받은 데이터(파라미터)를 검증하거나 가공하여 Service 계층으로 전달합니다. 비즈니스 로직을 직접 처리하지 않습니다.
      * **예시 코드 (Controller):**
        ```java
        @Controller
        @RequestMapping("/board")
        public class BoardController {
            @Autowired
            private BoardService boardService; // Service 객체 의존성 주입

            @PostMapping("/write")
            public String writeBoard(BoardVO boardVO) {
                // 1. 요청 데이터를 Service에 전달
                boardService.insertBoard(boardVO);
                // 4. 처리 완료 후 응답할 View 이름 반환 (redirect)
                return "redirect:/board/list"; 
            }
        }
        ```

2.  **Controller $\rightarrow$ Service:** Controller는 요청에 필요한 비즈니스 로직 처리를 **Service** 계층에 위임합니다.

      * **역할:** 트랜잭션을 관리하고, 여러 개의 DAO 메서드를 조합하여 복잡한 비즈니스 로직을 수행합니다. (예: 게시글 등록 시 포인트 지급, 여러 테이블에 걸친 데이터 처리 등)
      * **예시 코드 (Service):**
        ```java
        @Service
        public class BoardService {
            @Autowired
            private BoardDAO boardDAO; // DAO 객체 의존성 주입

            public void insertBoard(BoardVO boardVO) {
                // 2. 비즈니스 로직 (여기서는 단순하게 DAO 호출)
                boardDAO.insertBoard(boardVO); 
            }
        }
        ```

3.  **Service $\rightarrow$ DAO:** Service는 데이터베이스 접근이 필요한 로직을 **DAO** (Data Access Object) 계층에 위임합니다.

      * **역할:** 데이터베이스 연결/해제, SQL 쿼리 실행 등 순수한 데이터 접근 로직만 담당합니다. Service 계층과 DB 구현 기술(MyBatis, JPA 등) 사이의 가교 역할을 합니다.
      * **예시 코드 (DAO):**
        ```java
        @Repository
        public class BoardDAO {
            @Autowired
            private SqlSessionTemplate sqlSession; // MyBatis 사용 예시

            public void insertBoard(BoardVO boardVO) {
                // 3. DB에 접근하여 SQL 실행 (MyBatis의 insert 메서드 호출)
                sqlSession.insert("boardMapper.insertBoard", boardVO);
            }
        }
        ```

4.  **DAO $\rightarrow$ Service $\rightarrow$ Controller:** DAO는 결과를 Service로, Service는 최종 결과를 Controller로 다시 반환합니다.

5.  **Controller $\rightarrow$ View:** Controller는 비즈니스 로직 처리 결과를 바탕으로 **View** (JSP, Thymeleaf 등) 이름을 반환하고, View는 최종적으로 클라이언트에게 HTML 형태로 응답을 생성하여 전송합니다.

-----

### 2\. [실습] 게시글 작성 요청 처리 과정

사용자가 '게시글 작성' 버튼 클릭 (HTTP POST 요청) 시 각 컴포넌트의 역할 및 데이터 흐름:

| 순서 | 컴포넌트 | 역할 및 수행 내용 | 데이터 흐름 |
| :--- | :--- | :--- | :--- |
| **1.** | **Controller** (`BoardController`) | 1. 사용자 요청(게시글 제목, 내용 등을 담은 HTTP 요청)을 받습니다. <br> 2. 받은 요청 데이터를 `BoardVO` 등의 객체로 바인딩합니다. <br> 3. 비즈니스 처리를 위해 `BoardService`를 호출합니다. | 클라이언트 $\rightarrow$ **`BoardVO`** $\rightarrow$ Service |
| **2.** | **Service** (`BoardService`) | 1. Controller로부터 `BoardVO`를 전달받습니다. <br> 2. 필요한 비즈니스 로직(예: 입력 값 유효성 검사, 트랜잭션 시작)을 수행합니다. <br> 3. DB 저장을 위해 `BoardDAO`를 호출합니다. | Controller $\rightarrow$ **`BoardVO`** $\rightarrow$ DAO |
| **3.** | **DAO** (`BoardDAO`) | 1. Service로부터 `BoardVO`를 전달받습니다. <br> 2. `BoardVO` 데이터를 매개변수로 사용하여 DB에 저장하는 INSERT SQL 쿼리를 실행합니다. <br> 3. 쿼리 실행 결과(성공/실패 등)를 Service로 반환합니다. | Service $\rightarrow$ **`BoardVO`** $\rightarrow$ DB (INSERT) |
| **4.** | **Service** (`BoardService`) | 1. DAO의 처리 결과를 받습니다. <br> 2. 트랜잭션을 커밋(Commit)하거나 롤백(Rollback)합니다. <br> 3. 처리 결과를 Controller로 반환합니다. | DAO $\rightarrow$ **결과(int)** $\rightarrow$ Controller |
| **5.** | **Controller** (`BoardController`) | 1. Service의 처리 결과를 받습니다. <br> 2. 게시글 목록 페이지로 리다이렉트(`"redirect:/board/list"`) 등의 응답을 결정합니다. | Service $\rightarrow$ **결과** $\rightarrow$ View (응답) |

-----

### 3\. [개념] SQL 결과값이 단일 데이터일 때 DAO 반환 형식

SQL 쿼리 실행 결과가 정확히 하나의 값(단일 데이터)인 경우, DAO 계층에서는 해당 데이터의 실제 Java 타입(Type)을 반환 타입으로 사용해야 합니다.

  * **예시:** 총 회원 수 $\rightarrow$ `int` 또는 `Long`
  * **예시:** 특정 상품의 가격 $\rightarrow$ `double` 또는 `BigDecimal`
  * **예시:** 하나의 날짜 값 $\rightarrow$ `Date` 또는 `LocalDate` / `LocalDateTime`
  * **MyBatis/JdbcTemplate 사용 시:** 기본 타입(Primitive Type) 또는 해당 기본 타입의 Wrapper 클래스(`Integer`, `Double`, `String` 등)를 반환 타입으로 지정합니다.

-----

### 4\. [실습] 단일 데이터 반환 DAO 메서드 시그니처

| 항목 | SQL 쿼리 예시 | DAO 메서드 시그니처 (Java) |
| :--- | :--- | :--- |
| **1) 사원의 최저 급여** | `select min(sal) from emp` | `public double getMinSalary();` |
| **2) 사원번호 7521의 사원명** | `select ename from emp where empno = 7521` | `public String getEmployeeName(int empNo);` |
| **3) 직책(CLERK)의 평균 급여** | `select avg(sal) from emp where job = 'CLERK'` | `public double getAverageSalaryByJob(String job);` |
| **문제 원본: 전체 고객의 평균 연봉** | `select avg(salary) from customers` | `public double getAverageCustomerSalary();` |

-----

### 5\. [개념] SQL 결과값이 한 컬럼 다중 행일 때 DAO 반환 형식

SQL 쿼리 실행 결과가 **하나의 컬럼이지만 여러 행의 데이터**를 반환하는 경우, DAO 계층에서는 **Java의 `List` 컬렉션**과 해당 컬럼의 실제 데이터 타입(Type)을 제네릭 타입으로 사용하여 반환해야 합니다.

  * **가장 적절한 반환 형식:** `java.util.List<T>`
      * 여기서 **T**는 해당 컬럼의 데이터에 매핑되는 Java 타입(예: `String`, `Integer`, `Date` 등)입니다.
  * **예시:** 모든 상품 이름 목록 $\rightarrow$ `List<String>`
  * **예시:** 모든 주문 번호 목록 $\rightarrow$ `List<Integer>`
  * **MyBatis/JdbcTemplate 사용 시:** 쿼리 결과의 각 행(각각 단일 컬럼 값)이 리스트의 한 요소로 매핑됩니다.

-----

### 6\. [실습] 한 컬럼 다중 행 반환 DAO 메서드 시그니처

| 항목 | SQL 쿼리 예시 | DAO 메서드 시그니처 (Java) |
| :--- | :--- | :--- |
| **1) DEPT의 위치(LOC) 목록** | `select distinct loc from dept` | `public List<String> getAllLocations();` |
| **2) 직책(JOB)별 사원명(ENAME) 목록** | `select ename from emp where job = ?` | `public List<String> getEmployeeNamesByJob(String job);` |
| **문제 원본: 회의 참석자 명단(이름만)** | `select attendee_name from meeting_attendees` | `public List<String> getAllAttendeeNames();` |

-----

### 7\. [개념] 단일 요청값, 단일 데이터 처리 DAO 기능 메서드 구조

단일 요청 값(예: 사원 ID)을 받아 단일 데이터(예: 해당 사원의 전체 정보)를 조회할 때 필요한 DAO 기능 메서드 구조는 다음과 같습니다.

  * **메서드 시그니처 구성:**

      * **반환 타입:** 조회하려는 데이터의 모든 컬럼을 포함하는 **Value Object (VO)** 또는 **Data Transfer Object (DTO)** 클래스 (예: `EmployeeVO`).
      * **메서드명:** 데이터 조회(SELECT) 기능을 나타내는 이름 (예: `selectById`, `getEmployee`, `findById`).
      * **매개변수:** 조회 조건이 되는 단일 값 (예: `int id`, `String userId`).

  * **예시 시그니처:**

    ```java
    public EmployeeVO getEmployeeById(int employeeId);
    ```

  * **SqlSessionTemplate (MyBatis) 핵심 메서드:**
    단일 요청에 의해 \*\*하나의 행(Row)\*\*의 데이터를 반환받을 때 사용되는 메서드는 **`selectOne`** 입니다.

    ```java
    sqlSession.selectOne("매퍼네임.SQL_ID", 매개변수); 
    ```

  * **JdbcTemplate 핵심 메서드:**
    `queryForObject` 메서드를 사용하며, 반환 타입을 명시해 줍니다.

    ```java
    jdbcTemplate.queryForObject(sql, new Object[]{매개변수}, RowMapper);
    ```

-----

### 8\. [실습] 단일 요청값 단일 데이터 처리 DAO 코드 구조

사용자 ID(`String userId`)를 받아 `UserVO` 객체를 반환하는 DAO 메서드의 전체적인 Java 코드 구조는 다음과 같습니다.

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Repository;
import org.mybatis.spring.SqlSessionTemplate;

// UserVO 클래스는 사용자 정보(ID, 이름, 이메일 등)를 담는 객체라고 가정합니다.
// class UserVO { ... } 

@Repository
public class UserDAO {

    // MyBatis를 사용하는 경우 SqlSessionTemplate 주입
    @Autowired
    private SqlSessionTemplate sqlSession;

    /**
     * 사용자 ID를 매개변수로 받아 해당 사용자의 모든 정보(UserVO)를 조회합니다.
     * @param userId 조회할 사용자의 ID
     * @return 조회된 사용자의 정보가 담긴 UserVO 객체
     */
    public UserVO selectUserById(String userId) {
        // [1] SqlSessionTemplate의 selectOne 메서드를 사용하여 단일 결과를 조회
        // 첫 번째 인자: 실행할 SQL의 매퍼 네임스페이스와 ID (예: "userMapper.selectUser")
        // 두 번째 인자: SQL에 전달할 파라미터 (userId)
        
        UserVO userVO = sqlSession.selectOne("userMapper.selectUser", userId);
        
        // TODO: 실제 MyBatis 매퍼 XML 파일에는 다음과 같은 쿼리가 정의되어 있어야 합니다.
        // <select id="selectUser" parameterType="String" resultType="com.example.UserVO">
        //     SELECT * FROM TBL_USER WHERE USER_ID = #{userId}
        // </select>
        
        // [2] 조회된 UserVO 객체를 Service 계층으로 반환
        return userVO;
    }
}
```

