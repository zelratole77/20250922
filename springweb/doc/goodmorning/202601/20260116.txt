Good morning QUIZ! 오늘도 좋은 하루 되시길~~ ^^

## **[I] 객관식 (4지선다형) - 20문항**

**1. 대량의 데이터를 조회할 때 페이징 처리를 수행하는 가장 주된 목적으로 적절하지 않은 것은?**
① 서버와 클라이언트 간의 데이터 전송 부하를 줄이기 위해
② 한 번에 너무 많은 데이터가 로드되어 브라우저가 다운되는 것을 방지하기 위해
#③ 데이터베이스의 전체 레코드 개수를 실시간으로 숨기기 위해
④ 사용자에게 필요한 범위의 데이터만 보여주어 가독성을 높이기 위해

**2. 제시된 SQL에서 전체 데이터 건수(`count(*)`)를 가장 먼저 조회하는 이유는 무엇입니까?**
① DB 성능 향상을 위해 인덱스를 타게 하려고
#② 페이징 알고리즘의 기초가 되는 '총 페이지 수'를 계산하기 위해
③ `rownum`의 최대치를 고정하기 위해
④ 검색 결과가 없는 경우 쿼리를 중단시키기 위해

**3. 페이징 처리의 대안으로 언급된 '스크롤 방식(Infinite Scroll)'의 특징으로 옳은 것은?**
① 주로 리스트형 업무 시스템에서 데이터의 정확한 위치 파악을 위해 쓰인다.
② 하단에 페이지 번호가 출력되어 원하는 페이지로 즉시 이동이 가능하다.
#③ 초기에는 지정한 건수만 보이다가 이벤트 발생 시 다음 범위 데이터를 로딩한다.
④ 데이터가 많아져도 총 데이터 건수를 확인하는 과정이 전혀 필요 없다.

**4. 다음 중 Java에서 '총 페이지 수'를 구하는 올바른 로직은? (단, `count`는 총건수, `pageSize`는 한 페이지당 출력 건수)**
① `(int)(Math.ceil(count / pageSize))`
#② `(int)(Math.ceil(count / (double)pageSize))`
③ `(int)(Math.floor(count / (double)pageSize))`
④ `(int)(count / pageSize) + 1`

**5. 한 페이지당 10건씩 보여주는 게시판에서 현재 3페이지를 보고자 할 때, SQL의 `BETWEEN` 조건에 들어갈 시작번호(start)와 마지막번호(end)로 옳은 것은?**
#① start: 21, end: 30
② start: 1, end: 10
③ start: 31, end: 40
④ start: 20, end: 30

**6. 제시된 소스 코드에서 `sch.getCurPage() == 0`일 때 `curPage`를 1로 설정하는 이유는 무엇입니까?**
① 페이지 번호는 0부터 시작하기 때문에
#② 초기 화면 진입 시 요청값이 없을 때 기본적으로 첫 페이지를 보여주기 위해
③ 데이터베이스 `rownum`이 0부터 시작하기 때문에
④ `pageSize`가 0이 되는 것을 방지하기 위해

**7. 총 데이터 건수가 18건이고 `pageSize`가 5일 때, 계산되는 '총 페이지 수'는 얼마입니까?**
① 3페이지
#② 4페이지
③ 5페이지
④ 18페이지

**8. `sch.setEnd(sch.getCurPage() * sch.getPageSize());` 연산 후
	 `if(sch.getEnd() > sch.getCount())` 조건을 체크하는 이유로 가장 적절한 것은?**
#① 마지막 페이지에서 실제 데이터 건수보다 더 큰 번호가 조회되는 것을 방지하기 위해
② SQL의 오동작을 막기 위해 `end` 값을 무조건 0으로 만들기 위해
③ `rownum`의 성능을 최적화하기 위해
④ 페이지 블록의 크기를 조절하기 위해

**9. 페이지 블록(Block) 기능에 대한 설명으로 틀린 것은?**
① 한 번에 보이는 페이지 번호의 리스트를 제한하는 기능이다.
② 이전/이후 버튼을 통해 블록 단위로 이동할 수 있다.
#③ 블록의 크기(`blockSize`)는 항상 총 페이지 수(`pageCount`)와 같아야 한다.
④ `startBlock`과 `endBlock`을 계산하여 화면 하단에 출력한다.

**10. 다음 중 현재 페이지 번호를 기반으로 `startBlock`을 구하는 알고리즘으로 적절한 것은? (단, `blockSize`는 블록 크기)**
#① `((curPage - 1) / blockSize) * blockSize + 1`
② `(curPage / blockSize) * blockSize`
③ `curPage - blockSize`
④ `(curPage + blockSize) / 2`

**11. Oracle SQL에서 페이징 처리를 위해 `ROWNUM`을 사용할 때, 서브쿼리를 사용하는 주된 이유는 무엇입니까?**
#① `WHERE` 절에서 `ROWNUM`을 1이 아닌 값부터 조회하려면 정렬된 결과에 번호를 먼저 매겨야 하기 때문
② `ROWNUM`은 오직 서브쿼리에서만 정의할 수 있는 예약어이기 때문
③ `ORDER BY`를 사용하면 `ROWNUM`이 자동으로 초기화되기 때문
④ `START WITH ... CONNECT BY` 절은 서브쿼리 없이는 작동하지 않기 때문

**12. 화면에서 `pageSize`(한 페이지당 보일 건수)를 변경했을 때, JavaScript에서 `curPage`를 1로 다시 설정하는 이유는?**
#① 페이지당 건수가 바뀌면 기존 페이지 번호의 데이터 범위가 달라져 혼란을 줄 수 있기 때문
② 서버 메모리를 절약하기 위해
③ 데이터베이스의 `count`를 다시 수행하지 않기 위해
④ `pageSize`가 커지면 무조건 데이터가 1페이지에 다 들어오기 때문

**13. 다음 중 `BoardSch` DTO(또는 모델)에서 **연산 알고리즘**에 의해 도출되는 값이 아닌 것은?**
① `start` (시작 번호)
② `end` (마지막 번호)
#③ `count` (총 데이터 건수) : DB 데이터를 그대로 가져온 내용
④ `pageCount` (총 페이지 수)

**14. 제시된 코드에서 `sch.setEndBlock(blockNum * sch.getBlockSize());` 계산 후 
 `if(sch.getEndBlock() > sch.getPageCount())` 처리를 하는 이유는?**
#① 블록의 마지막 번호가 실제 존재하는 마지막 페이지 번호를 초과하지 않게 하기 위해
② 다음 블록이 있는지 확인하기 위해
③ 현재 페이지를 블록의 중앙에 배치하기 위해
④ 모든 페이지 번호를 한꺼번에 출력하기 위해

**15. JSP의 페이징 UI 구현에서 `<c:forEach>`의 `begin`과 `end` 속성에 들어갈 값으로 가장 적절한 조합은?**
① `begin="${sch.start}"`, `end="${sch.end}"`
#② `begin="${sch.startBlock}"`, `end="${sch.endBlock}"`
③ `begin="1"`, `end="${sch.count}"`
④ `begin="${sch.curPage}"`, `end="${sch.pageCount}"`

**16. 현재 페이지 번호가 7이고 `blockSize`가 5일 때, 이 페이지가 속한 블록의 `startBlock`과 `endBlock`은?**
① startBlock: 1, endBlock: 5
② startBlock: 5, endBlock: 10
#③ startBlock: 6, endBlock: 10
④ startBlock: 7, endBlock: 11

**17. `sch.setStart((sch.getCurPage() - 1) * sch.getPageSize() + 1);` 공식에서 
`curPage`가 1일 때 `start` 값은 얼마인가?**
① 0
② 1
#③ 5
④ 10

**18. Controller단에서 `BoardSch` 객체를 `@ModelAttribute`로 선언하여 사용하는 장점은 무엇인가?**
① SQL 쿼리를 자동으로 생성해주기 때문에
#② 요청 파라미터를 객체에 자동으로 바인딩하고, 뷰(JSP)까지 데이터를 전달하기 편리해서
③ 데이터베이스 연결을 자동으로 종료해주기 때문에
④ 페이징 알고리즘을 Java가 아닌 HTML에서 처리하게 해주기 때문

**19. 게시판 리스트 하단에서 'Next' 버튼을 클릭했을 때 이동해야 할 페이지 번호를 구하는 식은?**
① `sch.curPage + 1`
② `sch.startBlock + 1`
#③ `sch.endBlock + 1`
④ `sch.pageCount + 1`

**20. 제시된 JSP 코드 중 `<li class="page-item ${sch.curPage == pcnt ? 'active' : ''}">` 구문의 역할은 무엇인가?**
① 모든 페이지 번호를 파란색으로 강조한다.
#② 현재 사용자가 보고 있는 페이지 번호에만 시각적 효과(배경색 등)를 준다.
③ 클릭할 수 없는 페이지 번호를 비활성화한다.
④ 데이터가 없는 페이지 번호를 화면에서 숨긴다.

---

## **[II] 주관식 (기술형) - 5문항**

**1. 페이징 처리 시 SQL에서 `ROWNUM`을 활용하여 범위를 지정할 때, `ORDER BY`와 `ROWNUM`의 
	실행 순서 관계에 따른 주의사항을 기술하시오.**
	rownum은 where 절 조건에 맞는 행에 순차적으로 부여되는데,
	order by보다 먼저 실행됩니다. 따라서 정렬된 순서대로 번호를 매기려면 반드시 정렬을 먼저 수행하는 서브쿼리를 사용..

**2. Java 서비스 로직에서 총 페이지 수(`pageCount`)를 계산할 때, 
	단순히 `총건수 / 페이지크기`를 하지 않고 
	`Math.ceil()`이나 추가적인 조건 처리를 해야 하는 이유를 설명하시오.**
	자바의 특성상  정수/정수 ==> 정수  ==> 실수 프로모트 (double)
	Math.ceil() 리턴이 실수여서 정수형으로 casting 필요 


**3. 게시판 화면 하단에 페이지 블록(예: 1~5, 6~10)을 도입했을 때, 사용자 경험(UX) 측면에서의 장점과
	 이를 구현하기 위해 필요한 핵심 변수 2가지를 기술하시오.**
	 한 번에 여러 페이지 번호를 보여주어 원하는 페이지로 빠르게 이동 가능(편의성 증대)
	 blockSize(블록당 페이지 수), startBlock(블록 시작 번호), endBlock(블록 끝 번호) 중 2가지..

**4. `pageSize`를 변경하는 `<select>` 박스 이벤트 발생 시, `curPage`를 무조건 1로 초기화하여 
	서버에 요청하는 이유를 데이터 정합성 관점에서 설명하시오.**
	선택시 마다 전체 페이지 구성 바뀌는 처리를 하고 있다... 그래서 기본 현재페이지 정보도 변경이 될 수 있기에
	초기화를 한다.

**5. 제공된 JSP 코드에서 `restCnt` 변수를 활용하여 빈 행(`<tr>&nbsp;</tr>`)을 
	출력하는 로직이 포함되어 있습니다. 이 처리를 하는 목적이 무엇인지 기술하시오.**
	데이터가 적은 페이지라도 게시판의 하단 디자인 위치를 고정적으로 처리하기 위해서..

---
